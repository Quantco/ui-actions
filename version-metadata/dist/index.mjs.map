{"version":3,"sources":["../src/index.ts","../src/utils.ts"],"sourcesContent":["import { normalize } from 'path'\nimport * as coreDefault from '@actions/core'\nimport { context, getOctokit } from '@actions/github'\nimport {\n  getSemverDiffType,\n  computeResponseFromChanges,\n  determineBaseAndHead,\n  deduplicateConsecutive,\n  categorizeChangedFiles\n} from './utils'\nimport type { VersionDiffType, VersionChange, VersionMetadataResponse } from './utils'\n\n// --- MOCKING ---\n\nconst coreMocked = {\n  setFailed: (msg: string) => {\n    console.error(msg)\n    process.exit(1)\n  },\n  getInput: (name: string) => {\n    const value = process.env[`INPUT_${name.replace(/-/g, '_').toUpperCase()}`]\n    if (value === undefined) {\n      throw new Error(`Input required and not supplied: ${name}`)\n    }\n    return value\n  },\n  setOutput(name: string, value: string) {\n    // this is the deprecated format for saving outputs in actions using commands only\n    // just using it here to have some sort of consistent output format\n    console.log(`::set-output name=${name}::${value}`)\n  }\n}\n\nconst core = process.env.MOCKING ? coreMocked : coreDefault\n\n/// --- MAIN ---\n\n// deal with inputs of the github action\nconst packageJsonFile = normalize(core.getInput('file') || 'package.json')\nconst token = core.getInput('token')\n\nasync function run(): Promise<VersionMetadataResponse> {\n  // octokit is the GitHub API client\n  // reference: https://octokit.github.io/rest.js/v19\n  // Goto type definition and looking around isn't all that useful as the types are auto-generated and\n  // basically describe the response types of a lot of rest calls using a lot of generic wrapper types.\n  //\n  // What works great however is auto-completion in the editor as the types for concrete objects are\n  // all resolved correctly, just not \"the bigger picture\" (meaning all useful types in one place).\n  const octokit = getOctokit(token)\n\n  const { base, head } = determineBaseAndHead(context)\n\n  // a lot of metadata about the files changed in between the base and head commits, the commits in between themselves, ...\n  const commitDiff = await octokit.rest.repos.compareCommits({\n    base,\n    head,\n    owner: context.repo.owner,\n    repo: context.repo.repo\n  })\n\n  // all changed files, categorized by type (added, modified, removed, renamed)\n  const changedFiles = commitDiff.data.files\n\n  if (!changedFiles) {\n    throw new Error('could not retrieve files changed in between base and head commits, aborting')\n  }\n\n  const changedFilesCategorized = categorizeChangedFiles(changedFiles)\n\n  // filter merge commits as they disrupt the versioning logic (they contain all changes of the PR again)\n  const commits = commitDiff.data.commits.filter((commit) => commit.parents.length === 1)\n\n  // all versions of the package.json file in between the base and head commits\n  // this has a lot of duplicates, as the file doesn't necessarily change in each commit\n  const maybeAllIterationsOfPackageJson = await Promise.all(\n    commits.map((commit) =>\n      octokit.rest.repos\n        .getContent({ owner: context.repo.owner, repo: context.repo.repo, path: packageJsonFile, ref: commit.sha })\n        .then((response) => ({ sha: commit.sha, response }))\n    )\n  )\n\n  const failedRequests = maybeAllIterationsOfPackageJson.filter(({ response }) => response.status !== 200)\n  if (failedRequests.length > 0) {\n    const failedSHAs = failedRequests.map(({ sha }) => sha).join(', ')\n    throw new Error(`could not retrieve all versions of \"${packageJsonFile}\" (${failedSHAs}), aborting`)\n  }\n\n  type NarrowedGetContentResponse = {\n    type: string\n    size: number\n    name: string\n    path: string\n    content?: string | undefined\n    sha: string\n    url: string\n    git_url: string | null\n    html_url: string | null\n    download_url: string | null\n  }\n\n  // can now assert that all requests were successful, as the status code is 200\n  const allIterationsOfPackageJson = maybeAllIterationsOfPackageJson.map(({ response, sha }) => ({\n    ...response.data,\n    sha\n  })) as NarrowedGetContentResponse[]\n\n  // remove duplicates from `allIterationsOfPackageJson`\n  const deduplicatedVersionsOfPackageJson = allIterationsOfPackageJson.reduce(\n    deduplicateConsecutive((x) => x.content),\n    { list: [], last: undefined }\n  ).list\n\n  // parse the contents of all the package.json files and map { version, sha } each time\n  const allVersionsOfPackageJson = deduplicatedVersionsOfPackageJson.map(({ content, sha, git_url: gitUrl }) => {\n    if (!content) throw new Error(`content is undefined, this should not happen (url: ${gitUrl}, sha: ${sha})`)\n    let parsed: { version?: string }\n    try {\n      parsed = JSON.parse(Buffer.from(content, 'base64').toString())\n    } catch (error) {\n      throw new Error(`Failed to parse JSON of package.json file (url: ${gitUrl}, sha: ${sha}, content: \"${content}\")`)\n    }\n    if (!parsed.version) throw new Error(`version is undefined, this should not happen (url: ${gitUrl}, sha: ${sha})`)\n\n    return { version: parsed.version, sha }\n  })\n\n  const deduplicatedVersions = allVersionsOfPackageJson.reduce(\n    deduplicateConsecutive((x) => x.version),\n    { list: [], last: undefined }\n  ).list\n\n  const oldVersion = deduplicatedVersions[0].version\n\n  // construct changes array from deduplicatedVersions\n  // this works by going over the array and for each pair of consecutive versions constructing a VersionChange object\n  const changes = deduplicatedVersions.reduce(\n    (acc, curr, index) => {\n      if (index === 0) return { list: [] as VersionChange[], last: curr }\n      if (!acc.last) throw new Error('acc.last is undefined, this should not happen')\n\n      const versionChange: VersionChange = {\n        oldVersion: acc.last.version,\n        newVersion: curr.version,\n        // we previously deduplicated consecutive versions, this means the diff type cannot be 'equal'\n        type: getSemverDiffType(acc.last.version, curr.version) as VersionDiffType,\n        commit: curr.sha\n      }\n      return { list: [...acc.list, versionChange], last: curr }\n    },\n    { list: [] as VersionChange[], last: undefined as { version: string; sha: string } | undefined }\n  ).list\n\n  return computeResponseFromChanges(changes, changedFilesCategorized, oldVersion, base, head)\n}\n\nrun()\n  .then((response) => {\n    // common outputs shared by both responses with and without version changes\n    core.setOutput('changed', response.changed.toString())\n    core.setOutput('oldVersion', response.oldVersion)\n    core.setOutput('commitBase', response.commitBase)\n    core.setOutput('commitHead', response.commitHead)\n    core.setOutput('changedFiles', JSON.stringify(response.changedFiles))\n    core.setOutput('changes', JSON.stringify(response.changes))\n    core.setOutput('json', JSON.stringify(response))\n\n    // output only present if there are version changes\n    if (response.changed) {\n      core.setOutput('type', response.type)\n      core.setOutput('newVersion', response.newVersion)\n      core.setOutput('commitResponsible', response.commitResponsible)\n    }\n  })\n  .catch((error) => core.setFailed(error.message))\n","import type { Context } from '@actions/github/lib/context'\n\nexport type VersionDiffType = 'major' | 'minor' | 'patch' | 'pre-release'\n\nexport type CategorizedChangedFiles = {\n  all: string[]\n  added: string[]\n  modified: string[]\n  removed: string[]\n  renamed: string[]\n}\n\nexport type VersionChange = {\n  oldVersion: string\n  newVersion: string\n  type: VersionDiffType\n  commit: string\n}\n\nexport type VersionMetadataResponse =\n  | {\n      /** Has the version changed since the last time the action was run? */\n      changed: false\n      oldVersion: string\n      /** commit SHA of the base commit (previous head before pushing / merging new commits) */\n      commitBase: string\n      /** commit SHA of the head commit */\n      commitHead: string\n      /** List of all changes to the version number since the last time the action was run. This includes old version, new version, type of change, and the commit SHA for each change */\n      changes: never[]\n      /** All files changed between the examined commits, categorized by type (added, modified, removed, renamed, all) */\n      changedFiles: CategorizedChangedFiles\n    }\n  | {\n      /** Has the version changed since the last time the action was run? */\n      changed: true\n      oldVersion: string\n      newVersion: string\n      /** Has the version changed since the last time the action was run? */\n      type: VersionDiffType\n      /** The SHA of the commit that last changed the version number */\n      commitResponsible: string\n      /** commit SHA of the base commit (previous head before pushing / merging new commits) */\n      commitBase: string\n      /** commit SHA of the head commit */\n      commitHead: string\n      /** All files changed between the examined commits, categorized by type (added, modified, removed, renamed, all) */\n      changedFiles: CategorizedChangedFiles\n      /** List of all changes to the version number since the last time the action was run. This includes old version, new version, type of change, and the commit SHA for each change */\n      changes: VersionChange[]\n    }\n\n/**\n * Parses a semver version string into its components\n * This only supports a somewhat rudimentary semver format with the following components:\n * - major (number; required)\n * - minor (number; required)\n * - patch (number; required)\n * - preRelease (string, optional)\n *\n * Thus:\n * - `major.minor.patch` is supported\n * - `major.minor.patch-preRelease` is supported\n *\n * @example\n * parseSemverVersion('1.0.0') // { major: 1, minor: 0, patch: 0, preRelease: undefined }\n * parseSemverVersion('1.0.0-3') // { major: 1, minor: 0, patch: 0, preRelease: '3' }\n * parseSemverVersion('1.2.3-4') // { major: 1, minor: 2, patch: 3, preRelease: '4' }\n * parseSemverVersion('1.0.0-beta') // { major: 1, minor: 0, patch: 0, preRelease: 'beta' }\n */\nconst parseSemverVersion = (version: string) => {\n  const [major, minor, maybePatch] = version.split('.')\n  const [patch, preRelease] = maybePatch.includes('-') ? maybePatch.split('-') : [maybePatch, undefined]\n\n  return {\n    major: parseInt(major),\n    minor: parseInt(minor),\n    patch: parseInt(patch),\n    preRelease\n  }\n}\n\n/**\n * Computes the type of change between two semver versions\n * Supports the same format as `parseSemverVersion`\n *\n * Returns `'equal'` if the versions are equal\n * Otherwise returns the largest change type\n *\n * @example\n * getSemverDiffType('1.0.0', '1.0.0') // 'equal'\n * getSemverDiffType('1.0.0', '1.0.1') // 'patch'\n * getSemverDiffType('1.0.0', '1.1.0') // 'minor'\n * getSemverDiffType('1.0.0', '2.0.0') // 'major'\n * getSemverDiffType('1.0.0', '2.0.4') // 'major'\n * getSemverDiffType('1.0.0', '1.0.0-beta') // 'pre-release'\n * getSemverDiffType('1.0.0-3', '1.0.0-4') // 'pre-release'\n * getSemverDiffType('1.0.0-beta', '1.0.0') // 'pre-release'\n * getSemverDiffType('1.2.3', '1.2.3') // 'equal'\n */\nconst getSemverDiffType = (versionA: string, versionB: string): VersionDiffType | 'equal' => {\n  const { major: majorA, minor: minorA, patch: patchA, preRelease: preReleaseA } = parseSemverVersion(versionA)\n  const { major: majorB, minor: minorB, patch: patchB, preRelease: preReleaseB } = parseSemverVersion(versionB)\n\n  if (majorA !== majorB) return 'major'\n  if (minorA !== minorB) return 'minor'\n  if (patchA !== patchB) return 'patch'\n  if (preReleaseA !== preReleaseB) return 'pre-release'\n\n  if (versionA === versionB) return 'equal'\n\n  throw new Error(\n    `Could not determine the type of change between '${versionA}' and '${versionB}', this should not happen`\n  )\n}\n\nconst computeResponseFromChanges = (\n  changes: VersionChange[],\n  changedFiles: CategorizedChangedFiles,\n  oldVersion: string,\n  base: string,\n  head: string\n): VersionMetadataResponse => {\n  if (changes.length === 0) {\n    return { changed: false, oldVersion, changes: [], changedFiles, commitBase: base, commitHead: head }\n  } else {\n    const newVersion = changes[changes.length - 1].newVersion\n    return {\n      changed: true,\n      oldVersion,\n      newVersion,\n      // we know that the versions differ, therefore we can safely assume that the type is not 'equal'\n      type: getSemverDiffType(oldVersion, newVersion) as VersionDiffType,\n      commitResponsible: changes[changes.length - 1].commit,\n      commitBase: base,\n      commitHead: head,\n      changes,\n      changedFiles\n    }\n  }\n}\n\n/**\n * Determines the base and head commits from the payload\n *\n * This is necessary because the payload for pull requests and pushes are different\n *\n * For PRs:\n * - context.payload.pull_request?.base?.sha\n * - context.payload.pull_request?.head?.sha\n *\n * For pushes:\n * - context.payload.before\n * - context.payload.after\n */\nconst determineBaseAndHead = (context: Context) => {\n  // Define the base and head commits to be extracted from the payload.\n  let base: string | undefined\n  let head: string | undefined\n\n  switch (context.eventName) {\n    case 'pull_request':\n      base = context.payload.pull_request?.base?.sha\n      head = context.payload.pull_request?.head?.sha\n      break\n    case 'push':\n      base = context.payload.before\n      head = context.payload.after\n      break\n    default:\n      throw new Error(\n        `This action only supports pull requests and pushes, ${context.eventName} events are not supported. ` +\n          \"Please submit an issue on this action's GitHub repo if you believe this in correct.\"\n      )\n  }\n\n  // Ensure that the base and head properties are set on the payload.\n  if (!base || !head) {\n    throw new Error(\n      `The base and head commits are missing from the payload for this ${context.eventName} event. ` +\n        \"Please submit an issue on this action's GitHub repo.\"\n    )\n  }\n\n  return { base, head }\n}\n\n/**\n * deduplicates consecutive elements in an array\n * Consecutive elements are determined by the result of the accessor function, meaning that it is\n * possible to determine equality based on a property of the element instead of the element itself.\n *\n * @example\n * const arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 1, 2]\n * const deduplicated = arr.reduce(deduplicateConsecutive((x) => x), { list: [], last: undefined }).list // [1, 2, 3, 4, 5, 1, 2]\n */\nconst deduplicateConsecutive =\n  <T, E>(accessor: (input: T) => E) =>\n  (acc: { list: T[]; last: E | undefined }, curr: T) => {\n    const value = accessor(curr)\n    if (!value) return acc\n    if (acc.last === value) return acc\n\n    return { list: [...acc.list, curr], last: value }\n  }\n\nconst categorizeChangedFiles = (\n  changedFiles: {\n    status: 'added' | 'modified' | 'removed' | 'renamed' | 'copied' | 'changed' | 'unchanged'\n    filename: string\n  }[]\n) => {\n  const all: string[] = []\n  const added: string[] = []\n  const modified: string[] = []\n  const removed: string[] = []\n  const renamed: string[] = []\n  for (const file of changedFiles) {\n    all.push(file.filename)\n    switch (file.status) {\n      case 'added':\n        added.push(file.filename)\n        break\n      case 'modified':\n        modified.push(file.filename)\n        break\n      case 'removed':\n        removed.push(file.filename)\n        break\n      case 'renamed':\n        renamed.push(file.filename)\n        break\n    }\n  }\n  return { all, added, modified, removed, renamed }\n}\n\nexport {\n  parseSemverVersion,\n  getSemverDiffType,\n  computeResponseFromChanges,\n  determineBaseAndHead,\n  deduplicateConsecutive,\n  categorizeChangedFiles\n}\n"],"mappings":"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","names":["context"]}